#!/bin/zsh
set -euo pipefail

# power_router.zsh
# One command to establish POWER SAVES (all roots route to one),
# and optionally scaffold FOX timing tools (strict, but always playable).
#
# Usage:
#   ./tools/power_router.zsh /path/to/cloud_save_root
#
# Options:
#   --no-fox     don't create fox scaffolding
#   --print      just print resolved plan, don't write files
#
# Notes:
# - zsh-only
# - safe: never pushes, never assumes prior commands
# - writes env to tools/.env/power_saves.env

die(){ print -r -- "power_router: $*" >&2; exit 1; }
need_dir(){ [[ -d "$1" ]] || die "not a directory: $1"; }
is_repo_root(){
  git rev-parse --show-toplevel >/dev/null 2>&1 || return 1
  local top; top="$(git rev-parse --show-toplevel)"
  [[ "$PWD" == "$top" ]]
}

NO_FOX=0
PRINT_ONLY=0
ROOT=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-fox) NO_FOX=1; shift ;;
    --print) PRINT_ONLY=1; shift ;;
    -h|--help)
      print -r -- "usage: $0 /path/to/cloud_save_root [--no-fox] [--print]"
      exit 0
      ;;
    *)
      if [[ -z "$ROOT" ]]; then ROOT="$1"; shift
      else die "unexpected arg: $1"
      fi
      ;;
  esac
done

[[ -n "$ROOT" ]] || die "missing root path. example: $0 \"$HOME/cloud_save\""
need_dir "$ROOT"

# Ensure we're in repo root (best practice)
if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
  die "not inside a git repo. cd into osu_megamix repo root and rerun."
fi
TOP="$(git rev-parse --show-toplevel)"
if [[ "$PWD" != "$TOP" ]]; then
  die "cd to repo root: $TOP"
fi

PLAN=()
PLAN+=("POWER_SAVES_ROOT=$ROOT")
PLAN+=("write tools/.env/power_saves.env")
PLAN+=("write tools/power_saves_root.zsh resolver")
PLAN+=("write docs/spec_power_saves.md")
if [[ "$NO_FOX" == "0" ]]; then
  PLAN+=("write tools/fox/fox.ps1 + tools/fox/fox.py (optional)")
  PLAN+=("write docs/spec_fox_windows.md")
fi

if [[ "$PRINT_ONLY" == "1" ]]; then
  print -r -- "power_router plan:"
  for p in "${PLAN[@]}"; do print -r -- "  - $p"; done
  exit 0
fi

mkdir -p tools/.env docs tools/fox

# 1) env file

cat > tools/.env/power_saves.env <<EOF
# POWER SAVES (generated by tools/power_router.zsh)
export POWER_SAVES_ROOT="$(print -r -- "$ROOT")"
EOF

# Mix Base (generated)
# default subdir name can be changed by setting MIX_BASE_SUBDIR before sourcing
echo "export MIX_BASE_SUBDIR=\"\"" >> tools/.env/power_saves.env
EOF


# 2) resolver script
cat > tools/power_saves_root.zsh <<'EOF'
#!/bin/zsh
set -euo pipefail

# POWER SAVES — authoritative root resolver
# prints the resolved root

# 1) explicit env wins
if [[ -n "${POWER_SAVES_ROOT:-}" ]]; then
  print -r -- "$POWER_SAVES_ROOT"
  exit 0
fi

# 2) known mounts (edit if desired)
candidates=(
  "$HOME/cloud_save"
  "/Volumes/cloud_save"
  "/mnt/cloud_save"
  "/mnt/power_saves"
)

for p in "${candidates[@]}"; do
  if [[ -d "$p" ]]; then
    print -r -- "$p"
    exit 0
  fi
done

# 3) fallback: repo root if available, else HOME
if command -v git >/dev/null 2>&1 && git rev-parse --show-toplevel >/dev/null 2>&1; then
  git rev-parse --show-toplevel
  exit 0
fi

print -r -- "$HOME"
EOF
chmod +x tools/power_saves_root.zsh

# 3) spec doc (Power Saves)
cat > docs/spec_power_saves.md <<'EOF'
# Power Saves — Authoritative Root Routing

**Power Saves** is the contract that a Mac↔PC linked-root setup (via a route called `cloud save`)
routes **all roots** to **one shared authoritative root**.

## Invariant

- All filesystem roots resolve through `POWER_SAVES_ROOT`.
- If `POWER_SAVES_ROOT` is set, it wins.
- If not set, resolver may select a known mount path.
- Fallback remains runnable (repo root / HOME), but is not the linked root.

**Invariant:** All roots route to one.
If removing Power Saves changes what plays or where state is written, routing is broken.

## Files

- `tools/.env/power_saves.env` — generated env export
- `tools/power_saves_root.zsh` — resolver used by scripts and runtime

## Usage

From repo root:

- `source tools/.env/power_saves.env`
- `ROOT="$(./tools/power_saves_root.zsh)"`

All state should write under:

- `$ROOT/.power_saves/…` (or another clearly Power-Saves-scoped directory)
EOF

# 4) Optional FOX scaffolding (kept in tools/docs only for now)
if [[ "$NO_FOX" == "0" ]]; then
  cat > docs/spec_fox_windows.md <<'EOF'
# FOX Timing Windows — Strict, But Always Playable

FOX expresses Megamix timing as two windows:

- **W_judge** (adaptive): score/accuracy strictness that can tighten with consistency
- **W_play** (fixed): continuity window that never closes (always playable)

If timing exits W_judge, gameplay continues via bust semantics.
If timing exits W_play, gameplay still continues (never stops the mix), but is treated as a hard bust/drop.

## Invariant

- `W_play > 0` always.
EOF

  # fox.ps1 + fox.py minimal placeholder (so you can iterate later)
  cat > tools/fox/fox.ps1 <<'EOF'
# FOX (PowerShell entry) — optional tooling
# This stays as tooling; do not wire into runtime until you mirror decisions safely.
python .\tools\fox\fox.py --simulate
EOF

  cat > tools/fox/fox.py <<'EOF'
from __future__ import annotations
import random, statistics, argparse

def simulate(n=240, sigma=22.0, drift=0.0, seed=0):
    random.seed(seed)
    # minimal demo: print some fake errors so the scaffold is real
    errs = [random.gauss(drift, sigma) for _ in range(n)]
    print(f"hits={n} mean={statistics.mean(errs):.2f}ms stdev={statistics.pstdev(errs):.2f}ms")
    print("note: replace this placeholder with the full FOX dual-window logic when ready.")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--simulate", action="store_true")
    ap.add_argument("--n", type=int, default=240)
    ap.add_argument("--sigma", type=float, default=22.0)
    ap.add_argument("--drift", type=float, default=0.0)
    ap.add_argument("--seed", type=int, default=0)
    args = ap.parse_args()
    if args.simulate:
        simulate(args.n, args.sigma, args.drift, args.seed)
    else:
        ap.print_help()

if __name__ == "__main__":
    main()
EOF
fi

# Print next steps (no push)
print -r -- ""
print -r -- "power_router: done."
print -r -- ""
print -r -- "NEXT:"
print -r -- "  source tools/.env/power_saves.env"
print -r -- "  ROOT=\"\$(./tools/power_saves_root.zsh)\""
print -r -- "  print -r -- \"POWER_SAVES_ROOT resolved -> \$ROOT\""
print -r -- ""
print -r -- "COMMIT (imagination*):"
print -r -- "  git add tools/power_saves_root.zsh tools/.env/power_saves.env docs/spec_power_saves.md"
if [[ "$NO_FOX" == "0" ]]; then
  print -r -- "  git add tools/fox docs/spec_fox_windows.md"
fi
print -r -- "  git commit -m \"imagination*: power saves (route all roots to one)\""
print -r -- ""
print -r -- "subtle flex: power saves: two machines, one root."
